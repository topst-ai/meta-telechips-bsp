From e39fdb8d3d1ff9986d1116be01af1256b0952702 Mon Sep 17 00:00:00 2001
From: Myunghwan Kim <mh.kim@telechips.com>
Date: Wed, 3 Apr 2024 10:35:20 +0900
Subject: [PATCH] missing part

---
 .../pci/controller/dwc/dolphin/pci-dolphin.c  | 733 ++++++++++++++----
 .../pci/controller/dwc/dolphin/pci-dolphin.h  |   8 +-
 drivers/phy/telechips/phy-sec08lpp-pcie.c     | 429 +++-------
 drivers/phy/telechips/phy-sec14lpp-pcie.c     |  44 +-
 drivers/phy/telechips/phy-ss14lpp-pcie.c      |  32 +-
 5 files changed, 711 insertions(+), 535 deletions(-)

diff --git a/drivers/pci/controller/dwc/dolphin/pci-dolphin.c b/drivers/pci/controller/dwc/dolphin/pci-dolphin.c
index 013e2a053..adeea19d8 100644
--- a/drivers/pci/controller/dwc/dolphin/pci-dolphin.c
+++ b/drivers/pci/controller/dwc/dolphin/pci-dolphin.c
@@ -25,9 +25,6 @@
 #include "pci-dolphin.h"
 
 #define to_dolphin_pcie(x)	dev_get_drvdata((x)->dev)
-
-#define to_phy_submode(r, m) \
-	(((r) << 4) | (m))
 #define phy_set_clk(phy, mode) \
 	phy_set_mode_ext(phy, PHY_MODE_PCIE, mode)
 
@@ -97,7 +94,7 @@ struct dolphin_pcie {
 
 static s32 dolphin_pcie_backup_reg(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		const struct dw_pcie *pci = dp->pci;
@@ -118,7 +115,7 @@ static s32 dolphin_pcie_backup_reg(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_restore_reg(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		const struct dw_pcie *pci = dp->pci;
@@ -184,7 +181,7 @@ static inline void dolphin_pcie_writel(const struct dolphin_pcie *dp,
 #ifdef CONFIG_DEBUG_FS
 static s32 dolphin_pcie_grant_is_raised(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		struct timespec64 start, end, gap;
@@ -192,7 +189,7 @@ static s32 dolphin_pcie_grant_is_raised(const struct dolphin_pcie *dp)
 
 		mask = PCIE_LINK_CFG_VEN_MSG_GRANT_MASK;
 		ktime_get_ts64(&start);
-		while ((dolphin_pcie_readl(dp, DP_PCIE_REG_LINK, PCIE_LINK_CFG00) & mask) == 0x0U) {
+		while((dolphin_pcie_readl(dp, DP_PCIE_REG_LINK, PCIE_LINK_CFG00) & mask) == 0x0U) {
 			ktime_get_ts64(&end);
 			gap = timespec64_sub(end, start);
 			if ((timespec64_to_ns(&gap)/NSEC_PER_MSEC) > PCIE_VDM_GRANT_TIMEOUT) {
@@ -211,7 +208,7 @@ static s32 dolphin_pcie_grant_is_raised(const struct dolphin_pcie *dp)
 
 static int dolphin_pcie_send_vdm(void *data, u64 msg)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (data != NULL) {
 		const struct dolphin_pcie *dp = (const struct dolphin_pcie *)data;
@@ -260,7 +257,7 @@ static int dolphin_pcie_send_vdm(void *data, u64 msg)
 
 		/* wait for VEN_MSG_GRANT */
 		err = dolphin_pcie_grant_is_raised(dp);
-		if (err != 0) {
+		if (err != (s32)0) {
 			dev_err(pci->dev, "Failed to write vdm(%d)\n", err);
 		}
 
@@ -282,7 +279,7 @@ static int dolphin_pcie_send_vdm(void *data, u64 msg)
 
 static int dolphin_pcie_recv_vdm(void *data, u64 *msg)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((data != NULL) && (msg != NULL)) {
 		const struct dolphin_pcie *dp = (const struct dolphin_pcie *)data;
@@ -303,7 +300,7 @@ static int dolphin_pcie_recv_vdm(void *data, u64 *msg)
 
 static s32 dolphin_pcie_disable_loopback(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		struct dw_pcie *pci = dp->pci;
@@ -348,7 +345,7 @@ static s32 dolphin_pcie_disable_loopback(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_enable_loopback(const struct dolphin_pcie *dp, enum dolphin_pcie_loopback_mode mode)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		struct dw_pcie *pci = dp->pci;
@@ -399,7 +396,7 @@ static s32 dolphin_pcie_enable_loopback(const struct dolphin_pcie *dp, enum dolp
 
 static int dolphin_pcie_loopback_get_mode(void *data, u64 *val)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((data != NULL) && (val != NULL)) {
 		const struct dolphin_pcie *dp =
@@ -415,7 +412,7 @@ static int dolphin_pcie_loopback_get_mode(void *data, u64 *val)
 
 static int dolphin_pcie_loopback_set_mode(void *data, u64 val)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (data != NULL) {
 		struct dolphin_pcie *dp = (struct dolphin_pcie *)data;
@@ -441,7 +438,7 @@ static int dolphin_pcie_loopback_set_mode(void *data, u64 val)
 			err = -EINVAL;
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			dp->loopback_mode = mode;
 		}
 	} else {
@@ -453,7 +450,7 @@ static int dolphin_pcie_loopback_set_mode(void *data, u64 val)
 
 static int dolphin_pcie_get_link_speed(void *data, u64 *speed)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((data != NULL) && (speed != NULL)) {
 		const struct dolphin_pcie *dp = (const struct dolphin_pcie *)data;
@@ -473,7 +470,7 @@ static int dolphin_pcie_get_link_speed(void *data, u64 *speed)
 
 static int dolphin_pcie_set_link_speed(void *data, u64 speed)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (data != NULL) {
 		const struct dolphin_pcie *dp = (const struct dolphin_pcie *)data;
@@ -518,7 +515,7 @@ DEFINE_SIMPLE_ATTRIBUTE(dolphin_pcie_vdm_fops, dolphin_pcie_recv_vdm, dolphin_pc
 
 static s32 dolphin_pcie_debugfs_init(struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		struct dw_pcie *pci = dp->pci;
@@ -542,7 +539,7 @@ static s32 dolphin_pcie_debugfs_init(struct dolphin_pcie *dp)
 			err = -ENOMEM;
 		}
 	} else {
-		err = -EINVAL;
+		err= -EINVAL;
 	}
 
 	return err;
@@ -551,13 +548,13 @@ static s32 dolphin_pcie_debugfs_init(struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_reset_control(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
-		if (IS_ENABLED(CONFIG_RESET_TCC) != 0) {
+		if (IS_ENABLED(CONFIG_RESET_TCC) != (s32)0) {
 			if (dp->reset != NULL) {
 				err = reset_control_assert(dp->reset);
-				if (err == 0) {
+				if (err == (s32)0) {
 					mdelay(10);
 					err = reset_control_deassert(dp->reset);
 				}
@@ -572,7 +569,7 @@ static s32 dolphin_pcie_reset_control(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_disable_irq(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		const struct dw_pcie *pci = dp->pci;
@@ -580,7 +577,7 @@ static s32 dolphin_pcie_disable_irq(const struct dolphin_pcie *dp)
 		s32 irq;
 
 		irq = (dp->mode == DW_PCIE_RC_TYPE) ? pp->irq : dp->irq;
-		if (irq >= 0) {
+		if (irq >= (s32)0) {
 			disable_irq((u32)irq);
 		}
 	} else {
@@ -592,7 +589,7 @@ static s32 dolphin_pcie_disable_irq(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_enable_irq(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		const struct dw_pcie *pci = dp->pci;
@@ -600,7 +597,7 @@ static s32 dolphin_pcie_enable_irq(const struct dolphin_pcie *dp)
 		s32 irq;
 
 		irq = (dp->mode == DW_PCIE_RC_TYPE) ? pp->irq : dp->irq;
-		if (irq > 0) {
+		if (irq > (s32)0) {
 			enable_irq((u32)irq);
 		}
 	} else {
@@ -612,7 +609,7 @@ static s32 dolphin_pcie_enable_irq(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_gen4_init(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		struct dw_pcie *pci = dp->pci;
@@ -655,7 +652,7 @@ static s32 dolphin_pcie_gen4_init(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_clear_slv_addr_mask(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		u32 val, mask;
@@ -673,7 +670,7 @@ static s32 dolphin_pcie_clear_slv_addr_mask(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_set_dev_type(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		u32 val;
@@ -692,7 +689,7 @@ static s32 dolphin_pcie_set_dev_type(const struct dolphin_pcie *dp)
 			break;
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			u32 mask;
 
 			mask = PCIE_LINK_CFG_DEVICE_TYPE_MASK;
@@ -708,7 +705,7 @@ static s32 dolphin_pcie_set_dev_type(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_set_max_link_speed(struct dw_pcie *pci)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (pci != NULL) {
 		struct dolphin_pcie *dp = (struct dolphin_pcie *)to_dolphin_pcie(pci);
@@ -729,7 +726,7 @@ static s32 dolphin_pcie_set_max_link_speed(struct dw_pcie *pci)
 
 static s32 dolphin_pcie_set_layer(struct dw_pcie *pci)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (pci != NULL) {
 		struct dolphin_pcie *dp = (struct dolphin_pcie *)to_dolphin_pcie(pci);
@@ -759,11 +756,11 @@ static s32 dolphin_pcie_set_layer(struct dw_pcie *pci)
 
 static s32 dolphin_pcie_init_phy(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		err = phy_init(dp->phy);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_gen4_init(dp);
 		}
 	} else {
@@ -775,25 +772,25 @@ static s32 dolphin_pcie_init_phy(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_set_defaults(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		struct dw_pcie *pci = dp->pci;
 
 		err = dolphin_pcie_init_phy(dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_clear_slv_addr_mask(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_set_dev_type(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_set_max_link_speed(pci);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_set_layer(pci);
 		}
 	} else {
@@ -805,7 +802,7 @@ static s32 dolphin_pcie_set_defaults(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_enable_ltssm(const struct dolphin_pcie *dp, bool enable)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		u32 val, mask;
@@ -823,7 +820,7 @@ static s32 dolphin_pcie_enable_ltssm(const struct dolphin_pcie *dp, bool enable)
 
 static s32 dolphin_pcie_clear_cactive(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		u32 val, mask;
@@ -841,7 +838,7 @@ static s32 dolphin_pcie_clear_cactive(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_clear_interrupts(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		u32 val, mask;
@@ -859,7 +856,7 @@ static s32 dolphin_pcie_clear_interrupts(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_enable_interrupt(const struct dolphin_pcie *dp, bool enable)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		u32 offset, val, mask;
@@ -877,16 +874,16 @@ static s32 dolphin_pcie_enable_interrupt(const struct dolphin_pcie *dp, bool ena
 
 static s32 dolphin_pcie_set_interrupt(const struct dolphin_pcie *dp, bool enable)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		err = dolphin_pcie_clear_interrupts(dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_enable_interrupt(dp, enable);
 		}
 
-		if (err == 0) {
-			if ((IS_ENABLED(CONFIG_PCI_MSI) != 0) &&
+		if (err == (s32)0) {
+			if ((IS_ENABLED(CONFIG_PCI_MSI) != (s32)0) &&
 					(dp->mode == DW_PCIE_RC_TYPE)) {
 				struct dw_pcie *pci = dp->pci;
 				struct pcie_port *pp = &pci->pp;
@@ -930,7 +927,7 @@ static void dolphin_pcie_write_dbi(struct dw_pcie *pci, void __iomem *base,
 		}
 
 		if (!__builtin_add_overflow(size, 0, &sz)) {
-			if (dw_pcie_write(base + reg, sz, write_val) != 0) {
+			if (dw_pcie_write(base + reg, sz, write_val) != (s32)0) {
 				dev_err(pci->dev, "failed to write dbi register(0x%08x)\n", reg);
 			}
 		}
@@ -965,7 +962,7 @@ static void dolphin_pcie_write_dbi2(struct dw_pcie *pci, void __iomem *base, u32
 		const struct dolphin_pcie *dp = (const struct dolphin_pcie *)to_dolphin_pcie(pci);
 		s32 sz, err;
 
-		err = 0;
+		err = (s32)0;
 		if (!__builtin_add_overflow(size, 0, &sz)) {
 			if ((dp->variant == TCC805X) || (dp->variant == TCC807X)) {
 				reg |= PCIE_LINK_CFG_INDIRECT_ADDR_MASK;
@@ -977,7 +974,7 @@ static void dolphin_pcie_write_dbi2(struct dw_pcie *pci, void __iomem *base, u32
 			}
 		}
 
-		if (err != 0) {
+		if (err != (s32)0) {
 			dev_err(pci->dev, "failed to write dbi2 register(%d)\n", err);
 		}
 	}
@@ -1005,7 +1002,7 @@ static s32 dolphin_pcie_link_up(struct dw_pcie *pci)
 
 static s32 dolphin_pcie_check_link_up(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		struct dw_pcie *pci = dp->pci;
@@ -1032,13 +1029,13 @@ static s32 dolphin_pcie_check_link_up(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_establish_link(struct dw_pcie *pci)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (pci != NULL) {
 		const struct dolphin_pcie *dp = (const struct dolphin_pcie *)to_dolphin_pcie(pci);
 
 		err = dolphin_pcie_enable_ltssm(dp, true);
-		if (err == 0) {
+		if (err == (s32)0) {
 			if (dolphin_pcie_check_link_up(dp) == (s32)PCIE_LINK_UP) {
 				dev_err(pci->dev, "Link up\n");
 			} else {
@@ -1046,7 +1043,7 @@ static s32 dolphin_pcie_establish_link(struct dw_pcie *pci)
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_set_interrupt(dp, true);
 		}
 	} else {
@@ -1061,7 +1058,7 @@ static void	dolphin_pcie_stop_link(struct dw_pcie *pci)
 	if (pci != NULL) {
 		const struct dolphin_pcie *dp = (const struct dolphin_pcie *)to_dolphin_pcie(pci);
 
-		if (dolphin_pcie_enable_ltssm(dp, false) != 0) {
+		if (dolphin_pcie_enable_ltssm(dp, false) != (s32)0) {
 			dev_err(pci->dev, "failed to disable ltssm\n");
 		}
 	}
@@ -1077,7 +1074,7 @@ static const struct dw_pcie_ops dolphin_pcie_host_ops = {
 
 static s32 dolphin_pcie_host_init(struct pcie_port *pp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (pp != NULL) {
 		struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
@@ -1085,7 +1082,7 @@ static s32 dolphin_pcie_host_init(struct pcie_port *pp)
 		dw_pcie_setup_rc(pp);
 
 		err = pinctrl_pm_select_default_state(pci->dev);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_establish_link(pci);
 		}
 	} else {
@@ -1129,7 +1126,7 @@ static irqreturn_t dolphin_pcie_handle_msi_irq(struct pcie_port *pp)
 						}
 						pos++;
 					}
-				} while (pos != (unsigned long)MAX_MSI_IRQS_PER_CTRL);
+				} while(pos != (unsigned long)MAX_MSI_IRQS_PER_CTRL);
 			}
 		}
 	}
@@ -1151,9 +1148,9 @@ static irqreturn_t dolphin_pcie_irq_handler(s32 irq, void *arg)
 		mask = PCIE_LINK_CFG_INTX_MASK | PCIE_LINK_CFG_MSI_INT_MASK;
 		val = dolphin_pcie_readl(dp, DP_PCIE_REG_LINK, PCIE_LINK_CFG24) & mask;
 		if (val != 0x0U) {
-			if (IS_ENABLED(CONFIG_PCI_MSI) != 0) {
+			if (IS_ENABLED(CONFIG_PCI_MSI) != (s32)0) {
 				if ((dp->mode == DW_PCIE_RC_TYPE) &&
-						((val & PCIE_LINK_CFG_MSI_INT_MASK) != 0x0U)) {
+						(val & PCIE_LINK_CFG_MSI_INT_MASK)) {
 					ret = dolphin_pcie_handle_msi_irq(pp);
 				}
 			}
@@ -1171,14 +1168,14 @@ static irqreturn_t dolphin_pcie_irq_handler(s32 irq, void *arg)
 static s32 dolphin_pcie_prepare_rc(struct dolphin_pcie *dp, struct platform_device *pdev,
 		struct pcie_port *pp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) &&
 			(pdev != NULL) &&
 			(pp != NULL)) {
 		pp->ops = &dolphin_pcie_rc_ops;
 		pp->irq = platform_get_irq(pdev, 0U);
-		if (pp->irq > 0) {
+		if (pp->irq > (s32)0) {
 			err = devm_request_irq(&pdev->dev,
 					(u32)pp->irq, dolphin_pcie_irq_handler,
 					IRQF_SHARED, "telechips-pcie-rc",
@@ -1195,7 +1192,7 @@ static s32 dolphin_pcie_prepare_rc(struct dolphin_pcie *dp, struct platform_devi
 
 static s32 dolphin_pcie_deassert_pwrup_reset(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		if (dp->variant != TCC803X) {
@@ -1215,25 +1212,25 @@ static s32 dolphin_pcie_deassert_pwrup_reset(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_wake_up_phy(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
-		const struct dw_pcie *pci = (const struct dw_pcie *)dp->pci;
+		struct dw_pcie *pci = dp->pci;
 
 		err = phy_power_on(dp->phy);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = pinctrl_pm_select_idle_state(pci->dev);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_clear_interrupts(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_deassert_pwrup_reset(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = phy_reset(dp->phy);
 		}
 	} else {
@@ -1245,7 +1242,7 @@ static s32 dolphin_pcie_wake_up_phy(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_set_clksrc(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		u32 val, mask;
@@ -1279,15 +1276,14 @@ static s32 dolphin_pcie_set_clksrc(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_set_clk(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		err = dolphin_pcie_set_clksrc(dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			s32 submode;
-
-			if (!__builtin_add_overflow(to_phy_submode(dp->refclk_type, (u32)dp->mode), 0, &submode)) {
-				err = phy_set_clk(dp->phy, submode);
+			if (!__builtin_add_overflow(dp->refclk_type, 0, &submode)) {
+				err = phy_set_clk(dp->phy, (s32)dp->refclk_type);
 			}
 		}
 	} else {
@@ -1300,7 +1296,7 @@ static s32 dolphin_pcie_set_clk(const struct dolphin_pcie *dp)
 #ifdef CONFIG_PCIE_DW_EP
 static s32 dolphin_pcie_ep_reset_bar(struct dw_pcie *pci, s32 bar)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((pci != NULL) &&
 			(bar <= (s32)BAR_5)) {
@@ -1321,7 +1317,7 @@ static s32 dolphin_pcie_ep_reset_bar(struct dw_pcie *pci, s32 bar)
 
 static s32 dolphin_pcie_ep_get_iatu_unroll_support(struct dw_pcie *pci)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (pci != NULL) {
 		u32 val;
@@ -1361,34 +1357,477 @@ static void dolphin_pcie_ep_init(struct dw_pcie_ep *ep)
 
 		for (bar = (s32)BAR_0; bar <= (s32)BAR_5; bar++) {
 			err = dolphin_pcie_ep_reset_bar(pci, bar);
-			if (err != 0) {
+			if (err != (s32)0) {
 				break;
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = pinctrl_pm_select_default_state(pci->dev);
 		}
 	}
 }
 
-static s32 dolphin_pcie_ep_raise_legacy_irq(struct dw_pcie_ep *ep, u8 func_no)
+/* migrated, need to remove */
+#define CALC_PCIE_REG_OFFSET(b, o, e)	((u32)(b) + (u32)(o) + (u32)(e))
+#define CALC_LIMIT_ADDR(b, o)		((u64)(b) + (u64)(o))
+static u32 dolphin_pcie_readl_atu(struct dw_pcie *pci, u32 reg)
+{
+	u32 val = 0;
+
+	if (pci != NULL) {
+		if (pci->ops->read_dbi != NULL) {
+			val = pci->ops->read_dbi(pci, pci->atu_base, reg, 4);
+		} else {
+			if (dw_pcie_read(pci->atu_base + reg, 4, &val) != (s32)0) {
+				dev_err(pci->dev, "Read ATU address failed\n");
+			}
+		}
+	}
+
+	return val;
+}
+
+static void dolphin_pcie_writel_atu(struct dw_pcie *pci, u32 reg, u32 val)
+{
+	if (pci != NULL) {
+		if (pci->ops->write_dbi != NULL) {
+			pci->ops->write_dbi(pci, pci->atu_base, reg, 4, val);
+		} else {
+			if (dw_pcie_write(pci->atu_base + reg, 4, val) != (s32)0) {
+				dev_err(pci->dev, "Write ATU address failed\n");
+			}
+		}
+	}
+}
+
+static void dolphin_pcie_prog_outbound_atu_unroll(struct dw_pcie *pci, u8 func_no,
+		u32 index, u32 type,
+		u64 cpu_addr, u64 pci_addr,
+		size_t size)
+{
+	if (pci != NULL) {
+		const struct dw_pcie_ep *ep = (const struct dw_pcie_ep *)&pci->ep;
+
+		if (index < ep->num_ob_windows) {
+			u32 retries, val;
+			u32 offset = PCIE_GET_ATU_OUTB_UNR_REG_OFFSET(index);
+
+			if (!__builtin_sub_overflow(size, 1, &size)) {
+				u64 limit_addr = CALC_LIMIT_ADDR(cpu_addr, size);
+
+				dolphin_pcie_writel_atu(pci,
+						CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_LOWER_BASE, 0),
+						lower_32_bits(cpu_addr));
+				dolphin_pcie_writel_atu(pci,
+						CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_UPPER_BASE, 0),
+						upper_32_bits(cpu_addr));
+				dolphin_pcie_writel_atu(pci,
+						CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_LOWER_LIMIT, 0),
+						lower_32_bits(limit_addr));
+				dolphin_pcie_writel_atu(pci,
+						CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_UPPER_LIMIT, 0),
+						upper_32_bits(limit_addr));
+				dolphin_pcie_writel_atu(pci,
+						CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_LOWER_TARGET, 0),
+						lower_32_bits(pci_addr));
+				dolphin_pcie_writel_atu(pci,
+						CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_UPPER_TARGET, 0),
+						upper_32_bits(pci_addr));
+				dolphin_pcie_writel_atu(pci,
+						CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_REGION_CTRL1, 0),
+						type | PCIE_ATU_FUNC_NUM(func_no));
+				dolphin_pcie_writel_atu(pci,
+						CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_REGION_CTRL2, 0),
+						PCIE_ATU_ENABLE);
+
+				/*
+				 * Make sure ATU enable takes effect before any subsequent config
+				 * and I/O accesses.
+				 */
+				for (retries = 0; retries < (u32)LINK_WAIT_MAX_IATU_RETRIES; retries++) {
+					val = dolphin_pcie_readl_atu(pci,
+							CALC_PCIE_REG_OFFSET(offset, PCIE_ATU_UNR_REGION_CTRL2, 0));
+					if ((val & PCIE_ATU_ENABLE) != 0x0U) {
+						break;
+					} else {
+						mdelay(LINK_WAIT_IATU);
+					}
+				}
+
+				if (retries == (u32)LINK_WAIT_MAX_IATU_RETRIES) {
+					dev_err(pci->dev, "Outbound iATU is not being enabled\n");
+				}
+			} else {
+				dev_err(pci->dev, "Invalid Size\n");
+			}
+		}
+	}
+}
+
+static void dolphin_pcie_prog_outbound_atu_no_unroll(struct dw_pcie *pci, u8 func_no, u32 index,
+				  u32 type, u64 cpu_addr, u64 pci_addr,
+				  size_t size)
 {
-	s32 err = 0;
+	if (pci != NULL) {
+		const struct dw_pcie_ep *ep = (const struct dw_pcie_ep *)&pci->ep;
+
+		if (index < ep->num_ob_windows) {
+			if (!__builtin_sub_overflow(size, 1, &size)) {
+				u64 limit_addr = CALC_LIMIT_ADDR(cpu_addr, size);
+				u32 retries, val;
+
+				val = ((u32)PCIE_ATU_REGION_OUTBOUND | index);
+				dw_pcie_writel_dbi(pci, PCIE_ATU_VIEWPORT, val);
+				dw_pcie_writel_dbi(pci, PCIE_ATU_LOWER_BASE, lower_32_bits(cpu_addr));
+				dw_pcie_writel_dbi(pci, PCIE_ATU_UPPER_BASE, upper_32_bits(cpu_addr));
+				dw_pcie_writel_dbi(pci, PCIE_ATU_LIMIT, lower_32_bits(limit_addr));
+				dw_pcie_writel_dbi(pci, PCIE_ATU_LOWER_TARGET, lower_32_bits(pci_addr));
+				dw_pcie_writel_dbi(pci, PCIE_ATU_UPPER_TARGET, upper_32_bits(pci_addr));
+				dw_pcie_writel_dbi(pci, PCIE_ATU_CR1, type | PCIE_ATU_FUNC_NUM((u32)func_no));
+				dw_pcie_writel_dbi(pci, PCIE_ATU_CR2, (u32)PCIE_ATU_ENABLE);
+
+				/*
+				 * Make sure ATU enable takes effect before any subsequent config
+				 * and I/O accesses.
+				 */
+				for (retries = 0; retries < (u32)LINK_WAIT_MAX_IATU_RETRIES; retries++) {
+					val = dw_pcie_readl_dbi(pci, (u32)PCIE_ATU_CR2);
+					if ((val & (u32)PCIE_ATU_ENABLE) != 0x0U) {
+						break;
+					}
 
+					mdelay(LINK_WAIT_IATU);
+				}
+
+				if (retries == (u32)LINK_WAIT_MAX_IATU_RETRIES) {
+					dev_err(pci->dev, "Outbound iATU is not being enabled\n");
+				}
+			} else {
+				dev_err(pci->dev, "Invalid Size\n");
+			}
+		}
+	}
+}
+
+static void dolphin_pcie_prog_outbound_atu(struct dw_pcie *pci, u8 func_no, u32 index,
+				  u32 type, u64 cpu_addr, u64 pci_addr,
+				  size_t size)
+{
+	if (pci != NULL) {
+		if (pci->iatu_unroll_enabled != (u8)0) {
+			dolphin_pcie_prog_outbound_atu_unroll(pci, func_no, index, type,
+					cpu_addr, pci_addr, size);
+		} else {
+			dolphin_pcie_prog_outbound_atu_no_unroll(pci, func_no, index, type,
+					cpu_addr, pci_addr, size);
+		}
+	}
+}
+
+static int dolphin_pcie_ep_outbound_atu(struct dw_pcie_ep *ep, u8 func_no,
+				   phys_addr_t phys_addr,
+				   u64 pci_addr, size_t size)
+{
+	s32 err = (s32)0;
+
+	if (ep != NULL) {
+		struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+		unsigned long free_win;
+
+		free_win = find_first_zero_bit(ep->ob_window_map, ep->num_ob_windows);
+		if (free_win >= ep->num_ob_windows) {
+			dev_err(pci->dev, "No free outbound window\n");
+			err = -EINVAL;
+		} else {
+			dolphin_pcie_prog_outbound_atu(pci, func_no, (u32)free_win, PCIE_ATU_TYPE_MEM,
+					phys_addr, pci_addr, size);
+
+			set_bit((unsigned int)free_win, ep->ob_window_map);
+			ep->outbound_addr[free_win] = phys_addr;
+		}
+	} else {
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static s32 dolphin_pcie_ep_map_addr(struct pci_epc *epc, u8 func_no,
+			       phys_addr_t addr,
+			       u64 pci_addr, size_t size)
+{
+	s32 err = (s32)0;
+
+	if (epc != NULL) {
+		struct dw_pcie_ep *ep = epc_get_drvdata(epc);
+		struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+
+		err = dolphin_pcie_ep_outbound_atu(ep, func_no, addr, pci_addr, size);
+		if (err != (s32)0) {
+			dev_err(pci->dev, "Failed to enable address\n");
+		}
+	} else {
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static void dolphin_pcie_disable_atu(struct dw_pcie *pci, u32 index,
+			 enum dw_pcie_region_type type)
+{
+	if (pci != NULL) {
+		if ((type == DW_PCIE_REGION_INBOUND) ||
+				(type == DW_PCIE_REGION_OUTBOUND)) {
+			u32 region = (type == DW_PCIE_REGION_INBOUND) ?
+				PCIE_ATU_REGION_INBOUND : PCIE_ATU_REGION_OUTBOUND;
+
+			dw_pcie_writel_dbi(pci, PCIE_ATU_VIEWPORT, region | index);
+			dw_pcie_writel_dbi(pci, PCIE_ATU_CR2, ~(u32)PCIE_ATU_ENABLE);
+		}
+	}
+}
+
+static int dolphin_pcie_find_index(const struct dw_pcie_ep *ep, phys_addr_t addr,
+			      u32 *atu_index)
+{
+	s32 err = (s32)0;
+
+	if (ep != NULL) {
+		u32 idx;
+
+		for (idx = 0; idx < ep->num_ob_windows; idx++) {
+			if (ep->outbound_addr[idx] != addr) {
+				continue;
+			} else {
+				*atu_index = idx;
+				break;
+			}
+		}
+
+		if (idx == ep->num_ob_windows) {
+			err = -EINVAL;
+		}
+	} else {
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static void dolphin_pcie_ep_unmap_addr(struct pci_epc *epc, u8 func_no,
+				  phys_addr_t addr)
+{
 	(void)func_no;
 
+	if (epc != NULL) {
+		const struct dw_pcie_ep *ep =
+			(const struct dw_pcie_ep *)epc_get_drvdata(epc);
+		struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+		u32 idx = (u32)0;
+
+		if (dolphin_pcie_find_index(ep, addr, &idx) == (s32)0) {
+			dolphin_pcie_disable_atu(pci, idx, DW_PCIE_REGION_OUTBOUND);
+			clear_bit(idx, ep->ob_window_map);
+		}
+	}
+}
+
+static unsigned int dolphin_pcie_ep_func_select(struct dw_pcie_ep *ep, u8 func_no)
+{
+	unsigned int func_offset = (unsigned int)0;
+
+	if (ep->ops->func_conf_select != NULL) {
+		func_offset = ep->ops->func_conf_select(ep, func_no);
+	}
+
+	return func_offset;
+}
+
+static struct dw_pcie_ep_func *
+dolphin_pcie_ep_get_func_from_ep(const struct dw_pcie_ep *ep, u8 func_no)
+{
+	struct dw_pcie_ep_func *ep_func = NULL;
+
+	if (ep != NULL) {
+		struct dw_pcie_ep_func *tmp;
+
+		list_for_each_entry(tmp, &ep->func_list, list) {
+			if (tmp->func_no == func_no) {
+				ep_func = tmp;
+				break;
+			}
+		}
+	}
+
+	return ep_func;
+}
+
+static s32 dolphin_pcie_ep_get_msi_addr(struct dw_pcie_ep *ep, u8 func_no,
+		u64 *msg_addr, u16 *msg_data, unsigned int *aligned_offset)
+{
+	s32 err = (s32)0;
+
 	if (ep != NULL) {
 		struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
-		const struct dolphin_pcie *dp = (const struct dolphin_pcie *)to_dolphin_pcie(pci);
-		u32 val, mask;
+		const struct dw_pcie_ep_func *ep_func =
+			(const struct dw_pcie_ep_func *)dolphin_pcie_ep_get_func_from_ep(
+				(const struct dw_pcie_ep *)ep, func_no);
+		const struct pci_epc *epc = (const struct pci_epc *)ep->epc;
 
-		mask = PCIE_LINK_CFG_SYS_INT_MASK;
-		val = mask;
-		dolphin_pcie_writel(dp, DP_PCIE_REG_LINK, PCIE_LINK_CFG57, val, mask);
+		if ((ep_func == NULL) || (ep_func->msi_cap == (u8)0)) {
+			err = -EINVAL;
+		} else {
+			unsigned int func_offset;
+			u32 msg_addr_lower, msg_addr_upper, reg;
+			u32 offset, mask;
+			u16 msg_ctrl;
+			bool has_upper;
+
+			func_offset = dolphin_pcie_ep_func_select(ep, func_no);
+			if (!__builtin_add_overflow(func_offset, 0, &offset)) {
+				/* Raise MSI per the PCI Local Bus Specification Revision 3.0, 6.8.1. */
+				reg = CALC_PCIE_REG_OFFSET(ep_func->msi_cap, offset, PCI_MSI_FLAGS);
+				msg_ctrl = dw_pcie_readw_dbi(pci, reg);
+				has_upper = ((msg_ctrl & (u16)PCI_MSI_FLAGS_64BIT) != 0x0U) ? true : false;
+
+				reg = CALC_PCIE_REG_OFFSET(ep_func->msi_cap, offset, PCI_MSI_ADDRESS_LO);
+				msg_addr_lower = dw_pcie_readl_dbi(pci, reg);
+				if (has_upper) {
+					reg = CALC_PCIE_REG_OFFSET(ep_func->msi_cap, offset, PCI_MSI_ADDRESS_HI);
+					msg_addr_upper = dw_pcie_readl_dbi(pci, reg);
+					reg = CALC_PCIE_REG_OFFSET(ep_func->msi_cap, offset, PCI_MSI_DATA_64);
+					*msg_data = dw_pcie_readw_dbi(pci, reg);
+				} else {
+					msg_addr_upper = (u32)0;
+					reg = CALC_PCIE_REG_OFFSET(ep_func->msi_cap, offset, PCI_MSI_DATA_32);
+					*msg_data = dw_pcie_readw_dbi(pci, reg);
+				}
 
-		val = 0x0U;
-		dolphin_pcie_writel(dp, DP_PCIE_REG_LINK, PCIE_LINK_CFG57, val, mask);
+				if (!__builtin_sub_overflow(epc->mem->window.page_size, 1, &mask)) {
+					*aligned_offset = msg_addr_lower & mask;
+					*msg_addr = ((u64)msg_addr_upper << 32) | (msg_addr_lower & ~(*aligned_offset));
+				} else {
+					err = -EINVAL;
+				}
+			} else {
+				err = -EINVAL;
+			}
+		}
+	} else {
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static s32 dolphin_pcie_ep_raise_msi_irq(struct dw_pcie_ep *ep, u8 func_no,
+			     u8 interrupt_num)
+{
+	s32 err = (s32)0;
+
+	if (ep != NULL) {
+		struct pci_epc *epc = ep->epc;
+		unsigned int aligned_offset;
+		u64 msg_addr;
+		u16 msg_data;
+
+		err = dolphin_pcie_ep_get_msi_addr(ep, func_no,
+				&msg_addr, &msg_data, &aligned_offset);
+		if (err == (s32)0) {
+			u32 intr_num;
+
+			err = dolphin_pcie_ep_map_addr(epc, func_no, ep->msi_mem_phys, msg_addr,
+					epc->mem->window.page_size);
+			if (err == (s32)0) {
+				if (!__builtin_sub_overflow(interrupt_num, 1, &intr_num)) {
+					writel(((u32)msg_data | intr_num), ep->msi_mem + aligned_offset);
+					dolphin_pcie_ep_unmap_addr(epc, func_no, ep->msi_mem_phys);
+				} else {
+					err = -EINVAL;
+				}
+			}
+		}
+	} else {
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static struct pci_epf_msix_tbl* dolphin_pcie_ep_get_msix_table(struct dw_pcie_ep *ep, u8 func_no)
+{
+	struct pci_epf_msix_tbl *msix_tbl = NULL;
+
+	if (ep != NULL) {
+		struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+		const struct dw_pcie_ep_func *ep_func;
+
+		ep_func = (const struct dw_pcie_ep_func *)dolphin_pcie_ep_get_func_from_ep(ep, func_no);
+		if ((ep_func != NULL) && (ep_func->msix_cap != (u8)0)) {
+			unsigned int func_offset;
+			u32 reg, tbl_offset, offset;
+
+			func_offset = dolphin_pcie_ep_func_select(ep, func_no);
+			if (!__builtin_add_overflow(func_offset, PCI_MSIX_TABLE, &offset)) {
+				reg = CALC_PCIE_REG_OFFSET(ep_func->msix_cap, offset, 0);
+				tbl_offset = dw_pcie_readl_dbi(pci, reg);
+				tbl_offset &= (u32)PCI_MSIX_TABLE_OFFSET;
+				msix_tbl = ep->epf_bar[tbl_offset & (u32)PCI_MSIX_TABLE_BIR]->addr + tbl_offset;
+			}
+		}
+	}
+
+	return msix_tbl;
+}
+
+static s32 dolphin_pcie_ep_raise_msix_irq(struct dw_pcie_ep *ep, u8 func_no,
+			      u16 interrupt_num)
+{
+	s32 err = (s32)0;
+
+	if (ep != NULL) {
+		const struct pci_epf_msix_tbl *msix_tbl;
+
+		msix_tbl = (const struct pci_epf_msix_tbl *)dolphin_pcie_ep_get_msix_table(ep, func_no);
+		if (msix_tbl != NULL) {
+			u32 msg_data, vec_ctrl, intr_num;
+			u64 msg_addr;
+
+			if (!__builtin_sub_overflow(interrupt_num, 1, &intr_num)) {
+				msg_addr = msix_tbl[intr_num].msg_addr;
+				msg_data = msix_tbl[intr_num].msg_data;
+				vec_ctrl = msix_tbl[intr_num].vector_ctrl;
+
+				if ((vec_ctrl & (u32)PCI_MSIX_ENTRY_CTRL_MASKBIT) != 0x0U) {
+					err = -EPERM;
+				} else {
+					struct pci_epc *epc = ep->epc;
+
+					err = dolphin_pcie_ep_map_addr(epc,
+							func_no,
+							ep->msi_mem_phys,
+							msg_addr,
+							epc->mem->window.page_size);
+					if (err == (s32)0) {
+						u32 aligned_offset;
+						u64 mask;
+
+						if (!__builtin_sub_overflow(epc->mem->window.page_size, 1, &mask)) {
+							aligned_offset = lower_32_bits(msg_addr & mask);
+							writel(msg_data, ep->msi_mem + aligned_offset);
+
+							dolphin_pcie_ep_unmap_addr(epc, func_no, ep->msi_mem_phys);
+						} else {
+							err = -EINVAL;
+						}
+					}
+				}
+			} else {
+				err = -EINVAL;
+			}
+		}
 	} else {
 		err = -EINVAL;
 	}
@@ -1399,7 +1838,7 @@ static s32 dolphin_pcie_ep_raise_legacy_irq(struct dw_pcie_ep *ep, u8 func_no)
 static s32 dolphin_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,
 			     enum pci_epc_irq_type type, u16 interrupt_num)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (ep != NULL) {
 		struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
@@ -1410,17 +1849,15 @@ static s32 dolphin_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,
 			switch (type) {
 			case PCI_EPC_IRQ_MSI:
 				if (epc_features->msi_capable != 0U) {
-					err = dw_pcie_ep_raise_msi_irq(ep, func_no, intr_num);
+					err = dolphin_pcie_ep_raise_msi_irq(ep, func_no, intr_num);
 				}
 				break;
 			case PCI_EPC_IRQ_MSIX:
 				if (epc_features->msix_capable != 0U) {
-					err = dw_pcie_ep_raise_msix_irq(ep, func_no, intr_num);
+					err = dolphin_pcie_ep_raise_msix_irq(ep, func_no, intr_num);
 				}
 				break;
 			case PCI_EPC_IRQ_LEGACY:
-				err = dolphin_pcie_ep_raise_legacy_irq(ep, func_no);
-				break;
 			case PCI_EPC_IRQ_UNKNOWN:
 			default:
 				dev_err(pci->dev, "INVALID DEV type : %d\n", type);
@@ -1444,7 +1881,7 @@ static struct dw_pcie_ep_ops dolphin_pcie_ep_ops = {
 static s32 dolphin_pcie_prepare_ep(struct dolphin_pcie *dp, struct platform_device *pdev,
 		struct dw_pcie_ep *ep)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) &&
 			(pdev != NULL) &&
@@ -1459,7 +1896,7 @@ static s32 dolphin_pcie_prepare_ep(struct dolphin_pcie *dp, struct platform_devi
 
 			ep->ops = &dolphin_pcie_ep_ops;
 			dp->irq = platform_get_irq(pdev, 0);
-			if (dp->irq < 0) {
+			if (dp->irq < (s32)0) {
 				err = -ENODEV;
 			} else {
 				err = devm_request_irq(&pdev->dev,
@@ -1479,26 +1916,26 @@ static s32 dolphin_pcie_prepare_ep(struct dolphin_pcie *dp, struct platform_devi
 
 static s32 dolphin_pcie_add_pcie_ep(struct dolphin_pcie *dp, struct platform_device *pdev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) && (pdev != NULL)) {
 		struct dw_pcie *pci = dp->pci;
 		struct dw_pcie_ep *ep = &pci->ep;
 
 		err = dolphin_pcie_set_clk((const struct dolphin_pcie *)dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_prepare_ep(dp, pdev, ep);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_set_defaults((const struct dolphin_pcie *)dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_ep_get_iatu_unroll_support(pci);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			pci->dbi_base2 = pci->dbi_base + PCIE_DBI2_OFFSET;
 			err = dw_pcie_ep_init(ep);
 		}
@@ -1512,22 +1949,22 @@ static s32 dolphin_pcie_add_pcie_ep(struct dolphin_pcie *dp, struct platform_dev
 
 static s32 dolphin_pcie_add_pcie_port(struct dolphin_pcie *dp, struct platform_device *pdev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) && (pdev != NULL)) {
 		struct dw_pcie *pci = dp->pci;
 		struct pcie_port *pp = &pci->pp;
 
 		err = dolphin_pcie_set_clk((const struct dolphin_pcie *)dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_prepare_rc(dp, pdev, pp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_set_defaults((const struct dolphin_pcie *)dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dw_pcie_host_init(pp);
 		}
 	} else {
@@ -1540,11 +1977,11 @@ static s32 dolphin_pcie_add_pcie_port(struct dolphin_pcie *dp, struct platform_d
 static int dolphin_pcie_add_port(struct dolphin_pcie *dp,
 		struct platform_device *pdev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) && (pdev != NULL)) {
 		err = dolphin_pcie_wake_up_phy((const struct dolphin_pcie *)dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			switch (dp->mode) {
 			case DW_PCIE_RC_TYPE:
 				err = dolphin_pcie_add_pcie_port(dp, pdev);
@@ -1562,7 +1999,7 @@ static int dolphin_pcie_add_port(struct dolphin_pcie *dp,
 			}
 		}
 
-		if (err != 0) {
+		if (err != (s32)0) {
 			dev_err(&pdev->dev,
 					"failed to init controller as %s mode\n",
 					(dp->mode == DW_PCIE_EP_TYPE) ? "EP" : "RC");
@@ -1577,7 +2014,7 @@ static int dolphin_pcie_add_port(struct dolphin_pcie *dp,
 static s32 dolphin_pcie_parse_regs(struct platform_device *pdev,
 		struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) && (pdev != NULL)) {
 		struct resource *res;
@@ -1594,7 +2031,7 @@ static s32 dolphin_pcie_parse_regs(struct platform_device *pdev,
 			err = -ENODEV;
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			res = platform_get_resource_byname(pdev,
 					IORESOURCE_MEM, "dbi");
 			if (res != NULL) {
@@ -1683,7 +2120,7 @@ MODULE_DEVICE_TABLE(of, dolphin_pcie_of_match);
 static s32 dolphin_pcie_get_of_data(const struct platform_device *pdev,
 		struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((pdev != NULL) && (dp != NULL)) {
 		const struct of_device_id *match = (const struct of_device_id *)of_match_device(
@@ -1700,7 +2137,7 @@ static s32 dolphin_pcie_get_of_data(const struct platform_device *pdev,
 			err = -ENODEV;
 		}
 
-		if (err != 0) {
+		if (err != (s32)0) {
 			dev_err(&pdev->dev, "failed to get of_data\n");
 		}
 	} else {
@@ -1713,7 +2150,7 @@ static s32 dolphin_pcie_get_of_data(const struct platform_device *pdev,
 static s32 dolphin_pcie_parse_phy(struct platform_device *pdev,
 		struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) && (pdev != NULL)) {
 		dp->phy = devm_phy_get(&pdev->dev, "pcie-phy");
@@ -1731,10 +2168,10 @@ static s32 dolphin_pcie_parse_phy(struct platform_device *pdev,
 static s32 dolphin_pcie_parse_reset(struct platform_device *pdev,
 		struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) && (pdev != NULL)) {
-		if (IS_ENABLED(CONFIG_RESET_TCC) != 0) {
+		if (IS_ENABLED(CONFIG_RESET_TCC) != (s32)0) {
 			dp->reset = devm_reset_control_get(&pdev->dev, NULL);
 			if (IS_ERR(dp->reset)) {
 				err = (s32)PTR_ERR(dp->reset);
@@ -1750,13 +2187,13 @@ static s32 dolphin_pcie_parse_reset(struct platform_device *pdev,
 static s32 dolphin_pcie_parse_props(struct platform_device *pdev,
 		struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) && (pdev != NULL)) {
 		err = of_property_read_u32(pdev->dev.of_node,
 				"refclk_type", &dp->refclk_type);
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = of_property_read_u32(pdev->dev.of_node,
 					"max-link-speed", &dp->max_link_speed);
 		}
@@ -1770,20 +2207,20 @@ static s32 dolphin_pcie_parse_props(struct platform_device *pdev,
 static s32 dolphin_pcie_parse_dt(struct platform_device *pdev,
 		struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if ((dp != NULL) && (pdev != NULL)) {
 		err = dolphin_pcie_parse_regs(pdev, dp);
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_parse_phy(pdev, dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_parse_reset(pdev, dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_parse_props(pdev, dp);
 		}
 	} else {
@@ -1823,17 +2260,17 @@ static struct dolphin_pcie *dolphin_pcie_alloc_drvdata(struct platform_device *p
 static int dolphin_pcie_probe(struct platform_device *pdev)
 {
 	struct dolphin_pcie *dp;
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (pdev != NULL) {
 		dp = dolphin_pcie_alloc_drvdata(pdev);
 		if (dp != NULL) {
 			err = dolphin_pcie_get_of_data(pdev, dp);
-			if (err == 0) {
+			if (err == (s32)0) {
 				err = dolphin_pcie_parse_dt(pdev, dp);
 			}
 
-			if (err == 0) {
+			if (err == (s32)0) {
 				dp->pci->ops = &dolphin_pcie_host_ops;
 				dp->pci->dev = &pdev->dev;
 				platform_set_drvdata(pdev, dp);
@@ -1841,7 +2278,7 @@ static int dolphin_pcie_probe(struct platform_device *pdev)
 			}
 
 #ifdef CONFIG_DEBUG_FS
-			if (err == 0) {
+			if (err == (s32)0) {
 				err = dolphin_pcie_debugfs_init(dp);
 			}
 #endif
@@ -1857,19 +2294,19 @@ static int dolphin_pcie_probe(struct platform_device *pdev)
 
 static s32 dolphin_pcie_remove(struct platform_device *pdev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (pdev != NULL) {
 		const struct dolphin_pcie *dp =
 			(const struct dolphin_pcie *)platform_get_drvdata(pdev);
-		const struct dw_pcie *pci = (const struct dw_pcie *)dp->pci;
+		struct dw_pcie *pci = dp->pci;
 
 		err = dolphin_pcie_disable_irq(dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = pinctrl_pm_select_idle_state(pci->dev);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			mdelay(1);
 			err = pinctrl_pm_select_default_state(pci->dev);
 		}
@@ -1882,18 +2319,17 @@ static s32 dolphin_pcie_remove(struct platform_device *pdev)
 
 static int dolphin_pcie_suspend(struct device *dev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dev != NULL) {
-		const struct dolphin_pcie *dp =
-			(const struct dolphin_pcie *)dev_get_drvdata(dev);
+		struct dolphin_pcie *dp = dev_get_drvdata(dev);
 		struct dw_pcie *pci = dp->pci;
 
 		if (dp->mode == DW_PCIE_RC_TYPE) {
 			u32 val;
 
 			val = dw_pcie_readl_dbi(pci, PCI_COMMAND);
-			val &= ~(u32)PCI_COMMAND_MEMORY;
+			val &= ~PCI_COMMAND_MEMORY;
 			dw_pcie_writel_dbi(pci, PCI_COMMAND, val);
 		}
 	} else {
@@ -1905,18 +2341,17 @@ static int dolphin_pcie_suspend(struct device *dev)
 
 static int dolphin_pcie_resume(struct device *dev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dev != NULL) {
-		const struct dolphin_pcie *dp =
-			(const struct dolphin_pcie *)dev_get_drvdata(dev);
+		struct dolphin_pcie *dp = dev_get_drvdata(dev);
 		struct dw_pcie *pci = dp->pci;
 
 		if (dp->mode == DW_PCIE_RC_TYPE) {
 			u32 val;
 
 			val = dw_pcie_readl_dbi(pci, PCI_COMMAND);
-			val |= (u32)PCI_COMMAND_MEMORY;
+			val |= PCI_COMMAND_MEMORY;
 			dw_pcie_writel_dbi(pci, PCI_COMMAND, val);
 		}
 	} else {
@@ -1928,25 +2363,25 @@ static int dolphin_pcie_resume(struct device *dev)
 
 static s32 dolphin_pcie_reestablish_link(const struct dolphin_pcie *dp)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dp != NULL) {
 		struct dw_pcie *pci = dp->pci;
 
 		err = dolphin_pcie_reset_control(dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_wake_up_phy(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_set_clk(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_set_defaults(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			if (dp->mode == DW_PCIE_RC_TYPE) {
 				err = dolphin_pcie_host_init(&pci->pp);
 			} else if (dp->mode == DW_PCIE_EP_TYPE) {
@@ -1966,18 +2401,18 @@ static s32 dolphin_pcie_reestablish_link(const struct dolphin_pcie *dp)
 
 static s32 dolphin_pcie_resume_early(struct device *dev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dev != NULL) {
 		const struct dolphin_pcie *dp =
 			(const struct dolphin_pcie *)dev_get_drvdata(dev);
 
 		err = dolphin_pcie_reestablish_link(dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_restore_reg(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_enable_irq(dp);
 		}
 	} else {
@@ -1989,25 +2424,25 @@ static s32 dolphin_pcie_resume_early(struct device *dev)
 
 static s32 dolphin_pcie_suspend_late(struct device *dev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dev != NULL) {
 		const struct dolphin_pcie *dp =
 			(const struct dolphin_pcie *)dev_get_drvdata(dev);
 
 		err = dolphin_pcie_disable_irq(dp);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_backup_reg(dp);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = phy_power_off(dp->phy);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = dolphin_pcie_clear_cactive(dp);
 		}
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = pinctrl_pm_select_sleep_state(dev);
 		}
 	} else {
diff --git a/drivers/pci/controller/dwc/dolphin/pci-dolphin.h b/drivers/pci/controller/dwc/dolphin/pci-dolphin.h
index 92a844ad6..56c88061e 100644
--- a/drivers/pci/controller/dwc/dolphin/pci-dolphin.h
+++ b/drivers/pci/controller/dwc/dolphin/pci-dolphin.h
@@ -22,12 +22,17 @@
 #define PCIE_LINK_CFG30			(0x078U)
 #define PCIE_LINK_CFG31			(0x07CU)
 #define PCIE_LINK_CFG33			(0x084U)
+#define PCIE_LINK_CFG43			(0x0ACU)
 #define PCIE_LINK_CFG44			(0x0B0U)
 #define PCIE_LINK_CFG53			(0x0D4U)
 #define PCIE_LINK_CFG57			(0x0E4U)
+#define PCIE_LINK_CFG70			(0x118U)
+#define PCIE_LINK_CFG71			(0x11CU)
 #define PCIE_LINK_CFG88			(0x160U)
 #define PCIE_LINK_CFG89			(0x164U)
 #define PCIE_LINK_CFG91			(0x16CU)
+#define PCIE_LINK_CFG92			(0x170U)
+#define PCIE_LINK_CFG93			(0x174U)
 
 /*
  * PCIe controller wrapper DBI configuration registers
@@ -108,9 +113,6 @@
 #define PCIE_LINK_CFG_POWER_UP_RST_SHIFT		(6U)
 #define PCIE_LINK_CFG_POWER_UP_RST_MASK		((u32)0x1U << PCIE_LINK_CFG_POWER_UP_RST_SHIFT)
 
-#define PCIE_LINK_CFG_SYS_INT_SHIFT		(0U)
-#define PCIE_LINK_CFG_SYS_INT_MASK		((u32)0x1U << PCIE_LINK_CFG_SYS_INT_SHIFT)
-
 #define PCIE_CAP_LINK_SPEED_SHIFT		(16U)
 #define PCIE_CAP_LINK_SPEED_MASK		((u32)0xFU << PCIE_CAP_LINK_SPEED_SHIFT)
 
diff --git a/drivers/phy/telechips/phy-sec08lpp-pcie.c b/drivers/phy/telechips/phy-sec08lpp-pcie.c
index 53edfda3e..126fb6e87 100644
--- a/drivers/phy/telechips/phy-sec08lpp-pcie.c
+++ b/drivers/phy/telechips/phy-sec08lpp-pcie.c
@@ -19,31 +19,12 @@
  */
 #define PCIE_PMA_CMN_REG00B		(0x002CU)
 #define PCIE_PMA_CMN_REG016		(0x0058U)
-#define PCIE_PMA_CMN_REG024		(0x0090U)
-#define PCIE_PMA_CMN_REG025		(0x0094U)
-#define PCIE_PMA_CMN_REG10A		(0x0428U)
+#define PCIE_PMA_CMN_REG055		(0x0154U)
 #define PCIE_PMA_CMN_REG130		(0x04C0U)
 #define PCIE_PMA_CMN_REG13C		(0x04F0U)
-#define PCIE_PMA_CMN_REG153		(0x054CU)
-#define PCIE_PMA_CMN_REG17B		(0x05ECU)
-#define PCIE_PMA_TRSV_REG40B		(0x102CU)
-#define PCIE_PMA_TRSV_REG424		(0x1090U)
-#define PCIE_PMA_TRSV_REG47A		(0x11E8U)
-#define PCIE_PMA_TRSV_REG47B		(0x11ECU)
 #define PCIE_PMA_TRSV_REG47C		(0x11F0U)
-#define PCIE_PMA_TRSV_REG4CF		(0x133CU)
-#define PCIE_PMA_TRSV_REG516		(0x1458U)
-#define PCIE_PMA_TRSV_REG517		(0x145CU)
-#define PCIE_PMA_TRSV_REG518		(0x1460U)
-#define PCIE_PMA_TRSV_REG519		(0x1464U)
+#define PCIE_PMA_TRSV_REG486		(0x1218U)
 #define PCIE_PMA_TRSV_REG56D		(0x15B4U)
-#define PCIE_PMA_TRSV_REG5F1		(0x17C4U)
-#define PCIE_PMA_TRSV_REG5FD		(0x17F4U)
-
-/*
- * PCIe controller wrapper pcs configuration registers
- */
-#define PCIE_PCS_OUT_VEC_4		(0x0154U)
 
 /*
  * PCIe controller wrapper phy configuration registers
@@ -112,6 +93,7 @@
 #define PCIE_PHY_REG_PMA_CMN_RSTN_MASK		((u32)0x1U << PCIE_PHY_REG_PMA_CMN_RSTN_SHIFT)
 #define PCIE_PHY_REG_PMA_INIT_RSTN_MASK		((u32)0x1U << PCIE_PHY_REG_PMA_INIT_RSTN_SHIFT)
 
+
 #define PCIE_PHY_REG_LPLL_REF_CLK_SEL_SHIFT		(3U)
 #define PCIE_PHY_REG_PORT0_REF_CLK_EN_SHIFT		(0U)
 #define PCIE_PHY_REG_LPLL_REF_CLK_SEL_MASK		((u32)0x3U << PCIE_PHY_REG_LPLL_REF_CLK_SEL_SHIFT)
@@ -132,69 +114,30 @@
 #define PCIE_PMA_ANA_LCPLL_AVC_MAN_CAP_BIAS_CODE_SHIFT		(3U)
 #define PCIE_PMA_ANA_LCPLL_AVC_MAN_CAP_BIAS_CODE_MASK		((u32)0x7U << PCIE_PMA_ANA_LCPLL_AVC_MAN_CAP_BIAS_CODE_SHIFT)
 
-#define PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G3_SHIFT		(0U)
-#define PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G3_MASK		((u32)0xFU << PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G3_SHIFT)
-
-#define PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G4_SHIFT		(4U)
-#define PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G4_MASK		((u32)0xFU << PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G4_SHIFT)
-
-#define PCIE_PMA_TG_LCPLL_FINE_LOCK_DELAY_TIME_SHIFT		(3U)
-#define PCIE_PMA_TG_LCPLL_FINE_LOCK_DELAY_TIME_MASK		((u32)0x7U << PCIE_PMA_TG_LCPLL_FINE_LOCK_DELAY_TIME_SHIFT)
-
-#define PCIE_PMA_PLL_LOCK_SHIFT		(2U)
-#define PCIE_PMA_PLL_LOCK_MASK		((u32)0x1U << PCIE_PMA_PLL_LOCK_SHIFT)
-
-#define PCIE_PMA_RX_MARGIN_SCALE_SHIFT		(2U)
-#define PCIE_PMA_RX_MARGIN_SCALE_MASK		((u32)0x3U << PCIE_PMA_RX_MARGIN_SCALE_SHIFT)
-
-#define PCIE_PMA_LANE_SEQ_AES_EN_SHIFT		(6U)
-#define PCIE_PMA_LANE_SEQ_AES_EN_MASK		((u32)0x1U << PCIE_PMA_LANE_SEQ_AES_EN_SHIFT)
-
-#define PCIE_PMA_LN0_OV_S_ANA_TX_DRV_IDRV_EN_SHIFT		(1U)
-#define PCIE_PMA_LN0_OV_S_ANA_TX_DRV_IDRV_EN_MASK		((u32)0x1U << PCIE_PMA_LN0_OV_S_ANA_TX_DRV_IDRV_EN_SHIFT)
-
-#define PCIE_PMA_LN0_ANA_TX_RESERVED_SHIFT		(0U)
-#define PCIE_PMA_LN0_ANA_TX_RESERVED_MASK		((u32)0xFFU << PCIE_PMA_LN0_ANA_TX_RESERVED_SHIFT)
-
-#define PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G3_SHIFT		(0U)
-#define PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G3_MASK		((u32)0xFFU << PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G3_SHIFT)
-
-#define PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G4_SHIFT		(0U)
-#define PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G4_MASK		((u32)0xFFU << PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G4_SHIFT)
-
 #define PCIE_PMA_LN0_ANA_RX_CDR_CCO_VCI_AMP_I_CTRL_SHIFT		(2U)
 #define PCIE_PMA_LN0_ANA_RX_CDR_CCO_VCI_AMP_I_CTRL_MASK		((u32)0x3U << PCIE_PMA_LN0_ANA_RX_CDR_CCO_VCI_AMP_I_CTRL_SHIFT)
 
-#define PCIE_PMA_LN0_BER_ADAP_RX_START_CURSOR_G4_SHIFT		(0U)
-#define PCIE_PMA_LN0_BER_ADAP_RX_START_CURSOR_G4_MASK		((u32)0x1FU << PCIE_PMA_LN0_BER_ADAP_RX_START_CURSOR_G4_SHIFT)
-
-#define PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G3_SHIFT		(0U)
-#define PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G3_MASK		((u32)0xFFU << PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G3_SHIFT)
-
-#define PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G3_SHIFT		(0U)
-#define PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G3_MASK		((u32)0xFFU << PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G3_SHIFT)
-
-#define PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G4_SHIFT		(0U)
-#define PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G4_MASK		((u32)0xFFU << PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G4_SHIFT)
-
-#define PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G4_SHIFT		(0U)
-#define PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G4_MASK		((u32)0xFFU << PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G4_SHIFT)
+#define PCIE_PMA_RX_OC_NUM_OF_SAMPLE_SHIFT		(2U)
+#define PCIE_PMA_RX_OC_EN_SHIFT		(0U)
+#define PCIE_PMA_RX_OC_NUM_OF_SAMPLE_MASK		((u32)0x7U << PCIE_PMA_RX_OC_NUM_OF_SAMPLE_SHIFT)
+#define PCIE_PMA_RX_OC_EN_MASK		((u32)0x1U << PCIE_PMA_RX_OC_EN_SHIFT)
 
 #define PCIE_PMA_LN0_OV_I_PMAD_RX_CTLE_RS_MF_CTRL_G4_SHIFT		(0U)
 #define PCIE_PMA_LN0_OV_I_PMAD_RX_CTLE_RS_MF_CTRL_G4_MASK		((u32)0x1FU << PCIE_PMA_LN0_OV_I_PMAD_RX_CTLE_RS_MF_CTRL_G4_SHIFT)
 
-#define PCIE_PMA_LN0_ANA_RX_RESERVED__7_0_SHIFT		(0U)
-#define PCIE_PMA_LN0_ANA_RX_RESERVED__7_0_MASK		((u32)0xFFU << PCIE_PMA_LN0_ANA_RX_RESERVED__7_0_SHIFT)
-
-#define PCIE_PMA_LN0_OV_S_PI_OFFSET_QCLK_SHIFT		(5U)
-#define PCIE_PMA_LN0_OV_S_PI_OFFSET_QCLK_MASK		((u32)0x1U << PCIE_PMA_LN0_OV_S_PI_OFFSET_QCLK_SHIFT)
-
-#define PCIE_PCS_PMA_CONTROL_VECTOR_MASK		(0xFFFFFU)
+#define PCIE_PMA_PLL_LOCK_SHIFT		(2U)
+#define PCIE_PMA_PLL_LOCK_MASK		((u32)0x1U << PCIE_PMA_PLL_LOCK_SHIFT)
 
 #define PCIE_CLK_CFG_PMS_PRESET		(0x201C8001U)
 #define PCIE_FBUS_CLK_RATE		(333333333UL)
 #define PCIE_PHY_CLK_RATE		(100000000UL)
 
+enum sec08lpp_ref_clk_src {
+	PCIE_REF_CLK_SRC_INTERNAL = 0,
+	PCIE_REF_CLK_SRC_EXTERNAL,
+	PCIE_REF_CLK_SRC_INVALID,
+};
+
 struct ber_preset {
 	s32 phase;
 	u32 offset;
@@ -205,7 +148,7 @@ static struct ber_preset ber_preset_table[] = {
 	/* Preset 0 */
 	{ 0, 0x5F8U, 0x00U, },
 	{ 0, 0x600U, 0x23U, },
-	{ 0, 0x604U, 0x44U, },
+	{ 0, 0x600U, 0x44U, },
 	{ 0, 0x608U, 0x61U, },
 	{ 0, 0x60CU, 0x55U, },
 	{ 0, 0x610U, 0x14U, },
@@ -336,8 +279,7 @@ struct sec08lpp_pcie_phy {
 	void __iomem *phy_base;
 	void __iomem *clk_base;
 	void __iomem *pma_base;
-	void __iomem *pcs_base;
-	u32 mode;
+	s32 mode;
 };
 
 static inline u32 sec08lpp_pcie_phy_readl(const void __iomem *base, u32 offset)
@@ -361,7 +303,7 @@ static inline void sec08lpp_pcie_phy_writel(void __iomem *base, u32 offset, u32
 
 static s32 sec08lpp_pcie_phy_reset(struct phy *phy)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (phy != NULL) {
 		const struct sec08lpp_pcie_phy *priv =
@@ -397,11 +339,11 @@ static s32 sec08lpp_pcie_phy_reset(struct phy *phy)
 
 static s32 sec08lpp_pcie_phy_enable_clk(const struct sec08lpp_pcie_phy *priv)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (priv != NULL) {
 		err = clk_prepare_enable(priv->fbus_clk);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = clk_prepare_enable(priv->phy_clk);
 		}
 	} else {
@@ -413,7 +355,7 @@ static s32 sec08lpp_pcie_phy_enable_clk(const struct sec08lpp_pcie_phy *priv)
 
 static s32 sec08lpp_pcie_phy_disable_clk(const struct sec08lpp_pcie_phy *priv)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (priv != NULL) {
 		clk_disable_unprepare(priv->phy_clk);
@@ -427,7 +369,7 @@ static s32 sec08lpp_pcie_phy_disable_clk(const struct sec08lpp_pcie_phy *priv)
 
 static s32 sec08lpp_pcie_phy_pma_pll_lock(const struct sec08lpp_pcie_phy *priv)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (priv != NULL) {
 		u32 val, mask;
@@ -464,16 +406,16 @@ static s32 sec08lpp_pcie_phy_disable_clkout(const struct sec08lpp_pcie_phy *priv
 	return err;
 }
 
-static s32 sec08lpp_pcie_phy_set_clk(const struct sec08lpp_pcie_phy *priv, u32 mode)
+static s32 sec08lpp_pcie_phy_set_refclk(const struct sec08lpp_pcie_phy *priv, u32 mode)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (priv != NULL) {
 		err = sec08lpp_pcie_phy_enable_clk(priv);
-		if (err == 0) {
+		if (err == (s32)0) {
 			u32 val, mask;
 
-			if ((mode & 0xF0U) == 0x0U) {
+			if (mode == 0x0U) {
 				/* RESERVED_CON b[20] */
 				mask = (u32)BIT(20);
 				val = 0x0U;
@@ -515,7 +457,7 @@ static s32 sec08lpp_pcie_phy_set_clk(const struct sec08lpp_pcie_phy *priv, u32 m
 					PCIE_PHY_REG_PORT0_REF_CLK_EN_MASK;
 				val = sec08lpp_pcie_phy_readl(priv->phy_base, PCIE_PHY_REG01) & ~mask;
 				val |= ((u32)0x1U << PCIE_PHY_REG_PORT0_REF_CLK_EN_SHIFT);
-				val |= (((mode & 0xF0U) >> 4U)  << PCIE_PHY_REG_LPLL_REF_CLK_SEL_SHIFT);
+				val |= (mode << PCIE_PHY_REG_LPLL_REF_CLK_SEL_SHIFT);
 				sec08lpp_pcie_phy_writel(priv->phy_base, PCIE_PHY_REG01, val, mask);
 			}
 		}
@@ -528,7 +470,7 @@ static s32 sec08lpp_pcie_phy_set_clk(const struct sec08lpp_pcie_phy *priv, u32 m
 
 static s32 sec08lpp_pcie_phy_set_mode(struct phy *phy, enum phy_mode mode, s32 submode)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (phy != NULL) {
 		struct sec08lpp_pcie_phy *priv = (struct sec08lpp_pcie_phy *)phy_get_drvdata(phy);
@@ -536,17 +478,13 @@ static s32 sec08lpp_pcie_phy_set_mode(struct phy *phy, enum phy_mode mode, s32 s
 		if ((mode != PHY_MODE_PCIE) || (submode < 0)) {
 			err = -EINVAL;
 		} else {
-			u8 clk_mode;
-
-			if (!__builtin_add_overflow(submode, 0, &clk_mode)) {
-				err = sec08lpp_pcie_phy_set_clk((const struct sec08lpp_pcie_phy *)priv, (u32)clk_mode);
-				if (err == 0) {
-					err = sec08lpp_pcie_phy_pma_pll_lock((const struct sec08lpp_pcie_phy *)priv);
-				}
+			err = sec08lpp_pcie_phy_set_refclk((const struct sec08lpp_pcie_phy *)priv, (u32)submode);
+			if (err == (s32)0) {
+				err = sec08lpp_pcie_phy_pma_pll_lock((const struct sec08lpp_pcie_phy *)priv);
+			}
 
-				if (err == 0) {
-					priv->mode = (u32)clk_mode;
-				}
+			if (err == (s32)0) {
+				priv->mode = submode;
 			}
 		}
 	} else {
@@ -556,32 +494,18 @@ static s32 sec08lpp_pcie_phy_set_mode(struct phy *phy, enum phy_mode mode, s32 s
 	return err;
 }
 
-static s32 sec08lpp_pcie_phy_pwr_down(const struct sec08lpp_pcie_phy *priv, bool enable)
-{
-	s32 err = 0;
-
-	if (priv != NULL) {
-		u32 val, mask;
-
-		mask = PCIE_PHY_REG_PMA_POWER_OFF_MASK;
-		val = enable ? mask : 0x0U;
-		sec08lpp_pcie_phy_writel(priv->phy_base, PCIE_PHY_REG04, val, mask);
-	} else {
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
 static s32 sec08lpp_pcie_phy_power_on(struct phy *phy)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (phy != NULL) {
 		const struct sec08lpp_pcie_phy *priv =
 			(const struct sec08lpp_pcie_phy *)phy_get_drvdata(phy);
+		u32 val, mask;
 
-		err = sec08lpp_pcie_phy_pwr_down(priv, false);
+		mask = PCIE_PHY_REG_PMA_POWER_OFF_MASK;
+		val = 0x0U;
+		sec08lpp_pcie_phy_writel(priv->phy_base, PCIE_PHY_REG04, val, mask);
 	} else {
 		err = -ENODEV;
 	}
@@ -591,173 +515,58 @@ static s32 sec08lpp_pcie_phy_power_on(struct phy *phy)
 
 static s32 sec08lpp_pcie_phy_power_off(struct phy *phy)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (phy != NULL) {
 		const struct sec08lpp_pcie_phy *priv =
 			(const struct sec08lpp_pcie_phy *)phy_get_drvdata(phy);
-
-		err = sec08lpp_pcie_phy_pwr_down(priv, true);
-	} else {
-		err = -ENODEV;
-	}
-
-	return err;
-}
-
-static s32 sec08lpp_pcie_phy_revert_to_default(const struct sec08lpp_pcie_phy *priv)
-{
-	s32 err = 0;
-
-	if (priv != NULL) {
 		u32 val, mask;
 
-		mask = PCIE_PMA_LANE_SEQ_AES_EN_MASK;
-		val = 0x0U;
-		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_CMN_REG17B, val, mask);
-
-		mask = PCIE_PMA_LN0_OV_S_ANA_TX_DRV_IDRV_EN_MASK;
+		mask = PCIE_PHY_REG_PMA_POWER_OFF_MASK;
 		val = mask;
-		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_TRSV_REG40B, val, mask);
-
-		mask = PCIE_PMA_LN0_OV_S_PI_OFFSET_QCLK_MASK;
-		val = 0x0U;
-		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_TRSV_REG5FD, val, mask);
+		sec08lpp_pcie_phy_writel(priv->phy_base, PCIE_PHY_REG04, val, mask);
 	} else {
-		err = -EINVAL;
+		err = -ENODEV;
 	}
 
 	return err;
 }
 
-static s32 sec08lpp_pcie_phy_sfr_init(const struct sec08lpp_pcie_phy *priv)
+static s32 sec08lpp_pcie_phy_init(struct phy *phy)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
-	if (priv != NULL) {
+	if (phy != NULL) {
+		const struct sec08lpp_pcie_phy *priv =
+			(const struct sec08lpp_pcie_phy *)phy_get_drvdata(phy);
 		u32 val, mask, idx;
 
-		mask = PCIE_PMA_ANA_LCPLL_AFC_VCO_CNT_RUN_NUM_MASK;
+		val = ((u32)0x3U << PCIE_PMA_RX_OC_NUM_OF_SAMPLE_SHIFT);
+		mask = PCIE_PMA_RX_OC_NUM_OF_SAMPLE_MASK | PCIE_PMA_RX_OC_EN_MASK;
+		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_TRSV_REG486, val, mask);
+
 		val = ((u32)0x11U << PCIE_PMA_ANA_LCPLL_AFC_VCO_CNT_RUN_NUM_SHIFT);
+		mask = PCIE_PMA_ANA_LCPLL_AFC_VCO_CNT_RUN_NUM_MASK;
 		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_CMN_REG00B, val, mask);
 
+		val = ((u32)0x4U << PCIE_PMA_ANA_LCPLL_AVC_MAN_CAP_BIAS_CODE_SHIFT);
 		mask = PCIE_PMA_ANA_LCPLL_AVC_MAN_CAP_BIAS_CODE_MASK;
-		val = ((u32)0x3U << PCIE_PMA_ANA_LCPLL_AVC_MAN_CAP_BIAS_CODE_SHIFT);
 		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_CMN_REG016, val, mask);
 
-		mask = PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G3_MASK;
-		val = ((u32)0x6U << PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G3_SHIFT);
-		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_CMN_REG024, val, mask);
-
-		mask = PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G4_MASK;
-		val = ((u32)0x6U << PCIE_PMA_ANA_LCPLL_ANA_LPF_R_SEL_LC1234_G4_SHIFT);
-		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_CMN_REG025, val, mask);
-
-		mask = PCIE_PMA_TG_LCPLL_FINE_LOCK_DELAY_TIME_MASK;
-		val = ((u32)0x7U << PCIE_PMA_TG_LCPLL_FINE_LOCK_DELAY_TIME_SHIFT);
-		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_CMN_REG10A, val, mask);
-
-		mask = PCIE_PMA_RX_MARGIN_SCALE_MASK;
-		val = ((u32)0x1U << PCIE_PMA_RX_MARGIN_SCALE_SHIFT);
-		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_CMN_REG153, val, mask);
-
-		mask = PCIE_PMA_LN0_ANA_TX_RESERVED_MASK;
-		val = ((u32)0x30U << PCIE_PMA_LN0_ANA_TX_RESERVED_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG424 + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
-		mask = PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G3_MASK;
-		val = ((u32)0x2U << PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G3_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG47A + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
-		mask = PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G4_MASK;
-		val = ((u32)0x4U << PCIE_PMA_LN0_ANA_RX_SR_RESERVED_G4_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG47B + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
+		val = 0x0U;
 		mask = PCIE_PMA_LN0_ANA_RX_CDR_CCO_VCI_AMP_I_CTRL_MASK;
-		val = ((u32)0x0U << PCIE_PMA_LN0_ANA_RX_CDR_CCO_VCI_AMP_I_CTRL_SHIFT);
 		for (idx = 0U; idx < 4U; idx++) {
 			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG47C + (idx * 0x1000U),
-					val,
-					mask);
+					(PCIE_PMA_TRSV_REG47C + (idx * 0x1000U)),
+					val, mask);
 		}
 
-		mask = PCIE_PMA_LN0_BER_ADAP_RX_START_CURSOR_G4_MASK;
-		val = ((u32)0xCU << PCIE_PMA_LN0_BER_ADAP_RX_START_CURSOR_G4_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG4CF + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
-		mask = PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G3_MASK;
-		val = ((u32)0xE5U << PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G3_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG516 + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
-		mask = PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G3_MASK;
-		val = ((u32)0xB6U << PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G3_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG517 + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
-		mask = PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G4_MASK;
-		val = ((u32)0xF5U << PCIE_PMA_LN0_RX_EQ_PH_0_1_TIMEOUT_G4_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG518 + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
-		mask = PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G4_MASK;
-		val = ((u32)0xC4U << PCIE_PMA_LN0_RX_EQ_PH_2_3_TIMEOUT_G4_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG519 + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
-		mask = PCIE_PMA_LN0_OV_I_PMAD_RX_CTLE_RS_MF_CTRL_G4_MASK;
 		val = ((u32)0x6U << PCIE_PMA_LN0_OV_I_PMAD_RX_CTLE_RS_MF_CTRL_G4_SHIFT);
+		mask = PCIE_PMA_LN0_OV_I_PMAD_RX_CTLE_RS_MF_CTRL_G4_MASK;
 		for (idx = 0U; idx < 4U; idx++) {
 			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG56D + (idx * 0x1000U),
-					val,
-					mask);
-		}
-
-		mask = PCIE_PMA_LN0_ANA_RX_RESERVED__7_0_MASK;
-		val = ((u32)0x33U << PCIE_PMA_LN0_ANA_RX_RESERVED__7_0_SHIFT);
-		for (idx = 0U; idx < 4U; idx++) {
-			sec08lpp_pcie_phy_writel(priv->pma_base,
-					PCIE_PMA_TRSV_REG5F1 + (idx * 0x1000U),
-					val,
-					mask);
+					(PCIE_PMA_TRSV_REG56D + (idx * 0x1000U)),
+					val, mask);
 		}
 
 		mask = 0xFFFFFFFFU;
@@ -773,33 +582,6 @@ static s32 sec08lpp_pcie_phy_sfr_init(const struct sec08lpp_pcie_phy *priv)
 		val = ((u32)0x1U << PCIE_PMA_IGNORE_ADAP_DONE_SHIFT);
 		mask = PCIE_PMA_IGNORE_ADAP_DONE_MASK;
 		sec08lpp_pcie_phy_writel(priv->pma_base, PCIE_PMA_CMN_REG130, val, mask);
-
-		mask = PCIE_PCS_PMA_CONTROL_VECTOR_MASK;
-		if((priv->mode & (u32)BIT(1)) != 0x0U) {
-			val = 0x700D5U;
-		} else {
-			val = 0x700DDU;
-		}
-		sec08lpp_pcie_phy_writel(priv->pcs_base, PCIE_PCS_OUT_VEC_4, val, mask);
-	} else {
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static s32 sec08lpp_pcie_phy_init(struct phy *phy)
-{
-	s32 err = 0;
-
-	if (phy != NULL) {
-		const struct sec08lpp_pcie_phy *priv =
-			(const struct sec08lpp_pcie_phy *)phy_get_drvdata(phy);
-
-		err = sec08lpp_pcie_phy_revert_to_default(priv);
-		if (err == 0) {
-			err = sec08lpp_pcie_phy_sfr_init(priv);
-		}
 	} else {
 		err = -ENODEV;
 	}
@@ -809,14 +591,13 @@ static s32 sec08lpp_pcie_phy_init(struct phy *phy)
 
 static s32 sec08lpp_pcie_phy_exit(struct phy *phy)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (phy != NULL) {
 		const struct sec08lpp_pcie_phy *priv =
 			(const struct sec08lpp_pcie_phy *)phy_get_drvdata(phy);
 
-		/* TODO */
-		(void)priv;
+		err = sec08lpp_pcie_phy_disable_clk(priv);
 	} else {
 		err = -ENODEV;
 	}
@@ -836,14 +617,14 @@ static const struct phy_ops sec08lpp_pcie_phy_ops = {
 
 static s32 sec08lpp_pcie_phy_suspend_late(struct device *dev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (dev != NULL) {
 		const struct sec08lpp_pcie_phy *priv =
 			(const struct sec08lpp_pcie_phy *)dev_get_drvdata(dev);
 
 		err = sec08lpp_pcie_phy_disable_clk(priv);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = sec08lpp_pcie_phy_disable_clkout(priv);
 		}
 	} else {
@@ -866,37 +647,12 @@ static const struct of_device_id sec08lpp_pcie_phy_id_table[] = {
 };
 MODULE_DEVICE_TABLE(of, sec08lpp_pcie_phy_id_table);
 
-static s32 sec08lpp_pcie_phy_of_parse_clk(struct platform_device *pdev, struct sec08lpp_pcie_phy *priv)
-{
-	s32 err = 0;
-
-	if ((pdev != NULL) && (priv != NULL)) {
-		priv->fbus_clk = devm_clk_get(&pdev->dev, "pcie_fbus");
-		if (IS_ERR(priv->fbus_clk)) {
-			err = (s32)PTR_ERR(priv->fbus_clk);
-		} else {
-			err = clk_set_rate(priv->fbus_clk, PCIE_FBUS_CLK_RATE);
-		}
-
-		if (err == 0) {
-			priv->phy_clk = devm_clk_get(&pdev->dev, "pcie_phy");
-			if (IS_ERR(priv->phy_clk)) {
-				err = (s32)PTR_ERR(priv->phy_clk);
-			} else {
-				err = clk_set_rate(priv->phy_clk, PCIE_PHY_CLK_RATE);
-			}
-		}
-	} else {
-		err = -EINVAL;
-	}
-	return err;
-}
-
-static s32 sec08lpp_pcie_phy_of_parse_reg(struct platform_device *pdev, struct sec08lpp_pcie_phy *priv)
+static s32 sec08lpp_pcie_phy_of_parse_dt(struct platform_device *pdev, struct sec08lpp_pcie_phy *priv)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
-	if ((pdev != NULL) && (priv != NULL)) {
+	if ((pdev != NULL) &&
+			(priv != NULL)) {
 		struct resource *res;
 
 		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy");
@@ -907,7 +663,7 @@ static s32 sec08lpp_pcie_phy_of_parse_reg(struct platform_device *pdev, struct s
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "clk");
 			if (res != NULL) {
 				priv->clk_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
@@ -917,7 +673,7 @@ static s32 sec08lpp_pcie_phy_of_parse_reg(struct platform_device *pdev, struct s
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pma");
 			if (res != NULL) {
 				priv->pma_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
@@ -927,30 +683,22 @@ static s32 sec08lpp_pcie_phy_of_parse_reg(struct platform_device *pdev, struct s
 			}
 		}
 
-		if (err == 0) {
-			res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pcs");
-			if (res != NULL) {
-				priv->pcs_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
-				if (IS_ERR(priv->pcs_base)) {
-					err = (s32)PTR_ERR(priv->pcs_base);
-				}
+		if (err == (s32)0) {
+			priv->fbus_clk = devm_clk_get(&pdev->dev, "pcie_fbus");
+			if (IS_ERR(priv->fbus_clk)) {
+				err = (s32)PTR_ERR(priv->fbus_clk);
+			} else {
+				err = clk_set_rate(priv->fbus_clk, PCIE_FBUS_CLK_RATE);
 			}
 		}
-	} else {
-		err = -EINVAL;
-	}
-	return err;
-}
-
-static s32 sec08lpp_pcie_phy_of_parse_dt(struct platform_device *pdev, struct sec08lpp_pcie_phy *priv)
-{
-	s32 err = 0;
 
-	if ((pdev != NULL) &&
-			(priv != NULL)) {
-		err = sec08lpp_pcie_phy_of_parse_reg(pdev, priv);
-		if (err == 0) {
-			err = sec08lpp_pcie_phy_of_parse_clk(pdev, priv);
+		if (err == (s32)0) {
+			priv->phy_clk = devm_clk_get(&pdev->dev, "pcie_phy");
+			if (IS_ERR(priv->phy_clk)) {
+				err = (s32)PTR_ERR(priv->phy_clk);
+			} else {
+				err = clk_set_rate(priv->phy_clk, PCIE_PHY_CLK_RATE);
+			}
 		}
 	} else {
 		err = -EINVAL;
@@ -961,7 +709,7 @@ static s32 sec08lpp_pcie_phy_of_parse_dt(struct platform_device *pdev, struct se
 
 static s32 sec08lpp_pcie_phy_register(struct sec08lpp_pcie_phy *priv)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (priv != NULL) {
 		struct phy_provider *provider;
@@ -988,19 +736,19 @@ static s32 sec08lpp_pcie_phy_register(struct sec08lpp_pcie_phy *priv)
 static s32 sec08lpp_pcie_phy_probe(struct platform_device *pdev)
 {
 	struct sec08lpp_pcie_phy *priv;
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	priv = (struct sec08lpp_pcie_phy *)devm_kzalloc(&pdev->dev,
 			sizeof(struct sec08lpp_pcie_phy), GFP_KERNEL);
 	if (priv != NULL) {
 		err = sec08lpp_pcie_phy_of_parse_dt(pdev, priv);
-		if (err == 0) {
+		if (err == (s32)0) {
 			priv->dev = &pdev->dev;
 			platform_set_drvdata(pdev, priv);
 			err = sec08lpp_pcie_phy_register(priv);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			pm_runtime_enable(priv->dev);
 		}
 	} else {
@@ -1012,14 +760,13 @@ static s32 sec08lpp_pcie_phy_probe(struct platform_device *pdev)
 
 static s32 sec08lpp_pcie_phy_remove(struct platform_device *pdev)
 {
-	s32 err = 0;
+	s32 err = (s32)0;
 
 	if (pdev != NULL) {
 		const struct sec08lpp_pcie_phy *priv =
 			(const struct sec08lpp_pcie_phy *)platform_get_drvdata(pdev);
 
 		pm_runtime_disable(priv->dev);
-		err = sec08lpp_pcie_phy_disable_clk(priv);
 	} else {
 		err = -ENODEV;
 	}
diff --git a/drivers/phy/telechips/phy-sec14lpp-pcie.c b/drivers/phy/telechips/phy-sec14lpp-pcie.c
index 6ebaa8409..4e0de8f09 100644
--- a/drivers/phy/telechips/phy-sec14lpp-pcie.c
+++ b/drivers/phy/telechips/phy-sec14lpp-pcie.c
@@ -85,7 +85,7 @@ struct sec14lpp_pcie_phy {
 	struct clk		*pcs_clk;
 	struct clk		*ref_clk;
 	u32 pms;
-	u32	mode;
+	s32	mode;
 };
 
 static inline u32 sec14lpp_pcie_phy_readl(const void __iomem *base, u32 offset)
@@ -113,19 +113,19 @@ static s32 sec14lpp_pcie_phy_enable_clk(const struct sec14lpp_pcie_phy *priv)
 
 	if (priv != NULL) {
 		err = clk_prepare_enable(priv->aux_clk);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = clk_prepare_enable(priv->apb_clk);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = clk_prepare_enable(priv->pcs_clk);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = clk_prepare_enable(priv->ref_clk);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = clk_prepare_enable(priv->fbus_clk);
 		}
 	} else {
@@ -151,17 +151,17 @@ static s32 sec14lpp_pcie_phy_disable_clk(const struct sec14lpp_pcie_phy *priv)
 	return err;
 }
 
-static s32 sec14lpp_pcie_phy_set_clk(const struct sec14lpp_pcie_phy *priv, u32 mode)
+static s32 sec14lpp_pcie_phy_set_clk(const struct sec14lpp_pcie_phy *priv, s32 submode)
 {
 	s32 err = 0;
 
 	if (priv != NULL) {
 		err = sec14lpp_pcie_phy_enable_clk(priv);
-		if (err == 0) {
+		if (err == (s32)0) {
 			u32 val, mask;
 
-			if ((mode & 0xF0U) == 0x0U) {
-				val = (0x1U << PCIE_PHY_ANA_PLL_CLK_OUT_TO_EXT_IO_SEL_SHIFT);
+			if (submode == (s32)0) {
+				val = (0x1U <<PCIE_PHY_ANA_PLL_CLK_OUT_TO_EXT_IO_SEL_SHIFT);
 				mask = PCIE_PHY_ANA_PLL_CLK_OUT_TO_EXT_IO_SEL_MASK;
 				sec14lpp_pcie_phy_writel(priv->phy_base, PCIE_PHY_CMN_REG062, val, mask);
 
@@ -202,13 +202,9 @@ static s32 sec14lpp_pcie_phy_set_mode(struct phy *phy, enum phy_mode mode, s32 s
 		struct sec14lpp_pcie_phy *priv = (struct sec14lpp_pcie_phy *)phy_get_drvdata(phy);
 
 		if (mode == PHY_MODE_PCIE) {
-			u8 clk_mode;
-
-			if (!__builtin_add_overflow(submode, 0, &clk_mode)) {
-				err = sec14lpp_pcie_phy_set_clk((const struct sec14lpp_pcie_phy *)priv, (u32)clk_mode);
-				if (err == 0) {
-					priv->mode = (u32)clk_mode;
-				}
+			err = sec14lpp_pcie_phy_set_clk((const struct sec14lpp_pcie_phy *)priv, submode);
+			if (err == (s32)0) {
+				priv->mode = submode;
 			}
 		} else {
 			err = -EINVAL;
@@ -377,7 +373,7 @@ static s32 sec14lpp_pcie_phy_of_parse_clk(struct platform_device *pdev, struct s
 			err = clk_set_rate(priv->aux_clk, PCIE_AUX_CLK_RATE);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			priv->apb_clk = devm_clk_get(&pdev->dev, "pcie_apb");
 			if (IS_ERR(priv->apb_clk)) {
 				err = (s32)PTR_ERR(priv->apb_clk);
@@ -386,7 +382,7 @@ static s32 sec14lpp_pcie_phy_of_parse_clk(struct platform_device *pdev, struct s
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			priv->pcs_clk = devm_clk_get(&pdev->dev, "pcie_pcs");
 			if (IS_ERR(priv->pcs_clk)) {
 				err = (s32)PTR_ERR(priv->pcs_clk);
@@ -395,21 +391,21 @@ static s32 sec14lpp_pcie_phy_of_parse_clk(struct platform_device *pdev, struct s
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			priv->fbus_clk = devm_clk_get(&pdev->dev, "fbus_hsio");
 			if (IS_ERR(priv->fbus_clk)) {
 				err = (s32)PTR_ERR(priv->fbus_clk);
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			priv->ref_clk = devm_clk_get(&pdev->dev, "pcie_ref");
 			if (!IS_ERR(priv->ref_clk)) {
 				err = clk_set_rate(priv->ref_clk, PCIE_REF_CLK_RATE);
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = of_property_read_u32(pdev->dev.of_node, "pms",
 					&priv->pms);
 		}
@@ -436,7 +432,7 @@ static s32 sec14lpp_pcie_phy_of_parse_reg(struct platform_device *pdev, struct s
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			res = platform_get_resource_byname(pdev,
 					IORESOURCE_MEM, "link");
 			if (res != NULL) {
@@ -459,8 +455,8 @@ static s32 sec14lpp_pcie_phy_of_parse_dt(struct platform_device *pdev, struct se
 
 	if ((pdev != NULL) && (priv != NULL)) {
 		err = sec14lpp_pcie_phy_of_parse_reg(pdev, priv);
-		if (err == 0) {
-			err = sec14lpp_pcie_phy_of_parse_clk(pdev, priv);
+		if (err == (s32)0) {
+			err =sec14lpp_pcie_phy_of_parse_clk(pdev, priv);
 		}
 	} else {
 		err = -EINVAL;
diff --git a/drivers/phy/telechips/phy-ss14lpp-pcie.c b/drivers/phy/telechips/phy-ss14lpp-pcie.c
index 2a0cb64e8..51ec32117 100644
--- a/drivers/phy/telechips/phy-ss14lpp-pcie.c
+++ b/drivers/phy/telechips/phy-ss14lpp-pcie.c
@@ -57,7 +57,7 @@ struct ss14lpp_pcie_phy {
 	struct clk	*phy_clk;
 	struct clk	*fbus_clk;
 	u32 pms;
-	u32	mode;
+	s32	mode;
 };
 
 static inline u32 ss14lpp_pcie_phy_readl(const void __iomem *base, u32 offset)
@@ -85,7 +85,7 @@ static s32 ss14lpp_pcie_phy_enable_clk(const struct ss14lpp_pcie_phy *priv)
 
 	if (priv != NULL) {
 		err = clk_prepare_enable(priv->fbus_clk);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = clk_prepare_enable(priv->phy_clk);
 		}
 	} else {
@@ -126,21 +126,21 @@ static s32 ss14lpp_pcie_phy_disable_clkout(const struct ss14lpp_pcie_phy *priv)
 	return err;
 }
 
-static s32 ss14lpp_pcie_phy_set_clk(const struct ss14lpp_pcie_phy *priv, u32 mode)
+static s32 ss14lpp_pcie_phy_set_clk(const struct ss14lpp_pcie_phy *priv, s32 submode)
 {
 	s32 err = 0;
 
 	if (priv != NULL) {
 		/* Use internal reference clock */
 		err = ss14lpp_pcie_phy_enable_clk(priv);
-		if (err == 0) {
+		if (err == (s32)0) {
 			u32 val, mask;
 
 			mask = PCIE_PHY_REG_REF_USE_PAD_MASK;
-			val = ((mode & 0xF0U) != 0x0U) ? mask : 0x0U;
+			val = (submode != (s32)0) ? mask : 0x0U;
 			ss14lpp_pcie_phy_writel(priv->phy_base, PCIE_PHY_REG08, val, mask);
 
-			if ((mode & 0xF0U) == 0x0U) {
+			if (submode == (s32)0) {
 				val = 0x0U;
 				mask = PCIE_CLK_CFG_RESETB_MASK;
 				ss14lpp_pcie_phy_writel(priv->clk_base, PCIE_CLK_CFG00, val, mask);
@@ -193,13 +193,9 @@ static s32 ss14lpp_pcie_phy_set_mode(struct phy *phy, enum phy_mode mode, s32 su
 		struct ss14lpp_pcie_phy *priv = (struct ss14lpp_pcie_phy *)phy_get_drvdata(phy);
 
 		if (mode == PHY_MODE_PCIE) {
-			u8 clk_mode;
-
-			if (!__builtin_add_overflow(submode, 0, &clk_mode)) {
-				err = ss14lpp_pcie_phy_set_clk((const struct ss14lpp_pcie_phy *)priv, (u32)clk_mode);
-				if (err == 0) {
-					priv->mode = (u32)clk_mode;
-				}
+			err = ss14lpp_pcie_phy_set_clk((const struct ss14lpp_pcie_phy *)priv, submode);
+			if (err == (s32)0) {
+				priv->mode = submode;
 			}
 		} else {
 			err = -EINVAL;
@@ -313,7 +309,7 @@ static s32 ss14lpp_pcie_phy_suspend_late(struct device *dev)
 			(const struct ss14lpp_pcie_phy *)dev_get_drvdata(dev);
 
 		err = ss14lpp_pcie_phy_disable_clk(priv);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = ss14lpp_pcie_phy_disable_clkout(priv);
 		}
 	} else {
@@ -350,7 +346,7 @@ static s32 ss14lpp_pcie_phy_of_parse_clk(struct platform_device *pdev, struct ss
 			err = clk_set_rate(priv->fbus_clk, PCIE_FBUS_CLK_RATE);
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			priv->phy_clk = devm_clk_get(&pdev->dev, "pcie_phy");
 			if (IS_ERR(priv->phy_clk)) {
 				err = (s32)PTR_ERR(priv->phy_clk);
@@ -359,7 +355,7 @@ static s32 ss14lpp_pcie_phy_of_parse_clk(struct platform_device *pdev, struct ss
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = of_property_read_u32(pdev->dev.of_node, "pms",
 					&priv->pms);
 		}
@@ -386,7 +382,7 @@ static s32 ss14lpp_pcie_phy_of_parse_reg(struct platform_device *pdev, struct ss
 			}
 		}
 
-		if (err == 0) {
+		if (err == (s32)0) {
 			res = platform_get_resource_byname(pdev,
 					IORESOURCE_MEM, "clk");
 			if (res != NULL) {
@@ -409,7 +405,7 @@ static s32 ss14lpp_pcie_phy_of_parse_dt(struct platform_device *pdev, struct ss1
 
 	if ((pdev != NULL) && (priv != NULL)) {
 		err = ss14lpp_pcie_phy_of_parse_reg(pdev, priv);
-		if (err == 0) {
+		if (err == (s32)0) {
 			err = ss14lpp_pcie_phy_of_parse_clk(pdev, priv);
 		}
 	} else {
-- 
2.34.1

